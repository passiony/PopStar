---
--- Generated by EmmyLua(https:--github.com/EmmyLua)
--- Created by GILLAR.
--- DateTime: 2023/12/16 10:03
---

---@class GameControl 游戏控制器
local GameControl = {}

function GameControl:Start()
    self:Init()
    self:CreateStar()
end

function GameControl:Init()
    ---玩家的数组
    ---@type table
    self.allStarArray = {}
    for i = 1, GameData.row do
        table.insert(self.allStarArray, {})
    end
    ---初始化游戏结束时检测的容器
    ---@type table
    self.overGameList = {};
    ---星星创建基础坐标
    ---@type CS.UnityEngine.Vector3
    self.mStarCreatBasePosition = Vector3(-600, -960, 0);
    ---创建星星的父节点
    ---@type CS.UnityEngine.Transform
    self.startContent = GamePanel.panel.transform:Find("Father")
    ---检测是否可消除的方向向量
    ---@type CS.UnityEngine.Vector3[]
    self.mDerectionList = { Vector3.up * 59, Vector3.down * 59, Vector3.left * 59, Vector3.right * 59 };
    --- 射线检测的距离设定
    ---@type number
    self.checkDistance = 1;
    --- 每消除一个星星的基础分
    ---@type number
    self.baseScore = 10;
    --- 多消除星星个数的额外分数
    ---@type number
    self.extraScoreFactor = 2;
    --- 遮罩
    ---@type CS.UnityEngine.GameObject
    self.cover = GamePanel.cover
    self.cover:SetActive(false);

    self.scaleFactor = UIManager.Instance:GetScaleFactor();
    ---所有星星预制体
    ---@type CS.UnityEngine.GameObject[]
    self.starPrefabs = {}
    ---可消除星星列表
    ---@type table
    self.destoryStarList = {}

    self.starPrefabs[1] = ResMgr.Instance:Load("Prefabs/BlueItem")
    self.starPrefabs[2] = ResMgr.Instance:Load("Prefabs/GreenItem")
    self.starPrefabs[3] = ResMgr.Instance:Load("Prefabs/OrangeItem")
    self.starPrefabs[4] = ResMgr.Instance:Load("Prefabs/PurpleItem")
    self.starPrefabs[5] = ResMgr.Instance:Load("Prefabs/RedItem")
    GamePanel.panel.OnGameEnd:AddListener(function()
        cs_coroutine.start(function()
            self:GameOverAfter()
        end)
    end)
end

---创建星星
function GameControl:CreateStar()
    for i = 1, GameData.row do
        for j = 1, GameData.colume do
            --计算第i行第j列的标准位置
            self.mStartPositon = self.mStarCreatBasePosition + 108 * Vector3(j, i, 0);

            --实例化方块
            local index = math.random(1, 5)
            local prefab = self.starPrefabs[index]
            local StarObj = GameObject.Instantiate(prefab, self.startContent)
            StarObj.name = "Star_" .. i .. "_" .. j

            local star = StarObj:GetComponent(typeof(Star));
            local transform = StarObj:GetComponent(typeof(RectTransform))
            --设置方块的位置
            transform.anchoredPosition3D = self.mStartPositon;
            self.allStarArray[i][j] = star
            --设置行列索引
            self.allStarArray[i][j].rowIndex = i;
            self.allStarArray[i][j].columnIndex = j;
            star.button.onClick:AddListener(function()
                self:RaycastStar(star);
                self:DestroyDestroyStar();
            end)
        end
    end

    self.isFull = true;
    GamePanel:Start()
end


--function GameControl:RaycastStar(onclickStar)
--    local StarTransform = onclickStar.transform;
--    for i, direction in ipairs(self.mDerectionList) do
--        local origin = StarTransform.position + direction * self.checkDistance
--        local layer = LayerMask.GetMask("Star")
--        Debug.DrawRay(origin, direction, Color.red, 5.0); -- 用以可视化
--        local hit = Physics2D.Raycast(Vector2(origin.x, origin.y), Vector2(direction.x, direction.y), self.checkDistance, layer);
--        if (hit.collider ~= nil) then
--            local hitStar = hit.collider:GetComponent(typeof(Star));
--            if (onclickStar.color == hitStar.color and not table.indexof(self.destoryStarList, hitStar)) then
--                table.insert(self.destoryStarList, hitStar)
--                self:RaycastStar(hitStar);
--            end
--        end
--    end
--end
---射线检测星星上下左右位置是否有相同颜色星星
---@param onclickStar CS.UnityEngine.GameObject 点击的星星
function GameControl:RaycastStar(onclickStar)
    local StarTransform = onclickStar.transform;
    for i, direction in ipairs(self.mDerectionList) do
        local origin = StarTransform.position + direction * self.checkDistance
        Debug.DrawRay(origin, direction, Color.red, 5.0); -- 用以可视化
        local hit = CS.PhysicsUtil.Raycast(origin, direction, self.checkDistance, "Star");
        if (hit.collider ~= nil) then
            local hitStar = hit.collider:GetComponent(typeof(Star));
            if (onclickStar.color == hitStar.color and not table.indexof(self.destoryStarList, hitStar)) then
                table.insert(self.destoryStarList, hitStar)
                self:RaycastStar(hitStar);
            end
        end
    end
end

---检测销毁星星
function GameControl:DestroyDestroyStar()
    if (#self.destoryStarList >= 2) then
        for i, item in ipairs(self.destoryStarList) do
            GameObject.Destroy(item.gameObject);
            self.allStarArray[item.rowIndex][item.columnIndex] = nil;
        end
        self.isFull = false;
        self:GetScore(self.destoryStarList);
        cs_coroutine.stopAll()
        cs_coroutine.start(function()
            self:DropStars();
            coroutine.yield(CS.UnityEngine.WaitForSeconds(2))
            if (self:IsLevelOver()) then
                print("游戏结束")
                self.isFull = true;
                self:GameOverAfter();
            end
        end)
        --cs_coroutine.start(function()
        --    coroutine.yield(CS.UnityEngine.WaitForSeconds(2))
        --    if (self:IsLevelOver()) then
        --        print("游戏结束1")
        --        self.isFull = true;
        --        coroutine.yield(CS.UnityEngine.WaitForSeconds(1))
        --        self:GameOverAfter();
        --    end
        --end)
    end

    self.destoryStarList = {}
end

---计算分数加成
---@param 消除星星个数
function GameControl:GetScore(stars)
    local score = 0;
    for i, v in ipairs(stars) do
        score = score + self.baseScore + (i * self.extraScoreFactor);
    end
    GameData.CurrentScore = GameData.CurrentScore + score;
    GamePanel:Refresh()
end

---检测是否游戏结束
function GameControl:IsLevelOver()
    if (self.isFull) then
        return false;
    end
    return not self:CanEliminateStars();
end

---检测是否又可以消除星星
function GameControl:CanEliminateStars()
    for i = 1, GameData.row do
        for j = 1, GameData.colume do
            if (self.allStarArray[i][j] ~= nil) then
                -- 如果当前位置有星星
                -- 检查当前星星上下左右四个方向是否有相同颜色的星星
                if (self:HasAdjacentSameColorStar(i, j)) then
                    return true; -- 存在可以消除的星星
                end
            end
        end
    end
end

---检测四周是否有相同颜色星星
---@param x number x 列数
---@param x number y 行数
function GameControl:HasAdjacentSameColorStar(x, y)
    -- 检查上方
    if (y + 1 < 10 and self.allStarArray[x][y + 1] and self.allStarArray[x][y].color == self.allStarArray[x][y + 1].color) then
        return true;
    end
    -- 检查下方
    if (y - 1 > 0 and self.allStarArray[x][y - 1] and self.allStarArray[x][y].color == self.allStarArray[x][y - 1].color) then
        return true;
    end
    -- 检查左侧
    if (x - 1 > 0 and self.allStarArray[x - 1][y] and self.allStarArray[x][y].color == self.allStarArray[x - 1][y].color) then
        return true;
    end
    -- 检查右侧
    if (x + 1 < 12 and self.allStarArray[x + 1][y] and self.allStarArray[x][y].color == self.allStarArray[x + 1][y].color) then
        return true;
    end
    -- 四个方向都没有相同颜色的星星
    return false;
end

--- 下落星星
function GameControl:DropStars()
    for y = 1, GameData.colume do
        for x = 1, GameData.row do
            --如果有元素为空
            if (self.allStarArray[x][y] == nil) then
                local moveCount = 0;
                --遍历x列空元素上面的所有元素 找到一个不为空的
                for above = x + 1, GameData.row do
                    moveCount = moveCount + 1
                    --如果不为空
                    if (self.allStarArray[above][y] ~= nil) then
                        --向下移动一格
                        self.allStarArray[x][y] = self.allStarArray[above][y];
                        self.allStarArray[x][y].gameObject.transform:DOMove(self.allStarArray[x][y].transform.position + Vector3.down * moveCount * 108, 0.1);
                        self.allStarArray[x][y].rowIndex = x;
                        self.allStarArray[x][y].columnIndex = y;
                        self.allStarArray[above][y] = nil;
                        break ;
                    end
                    if (above == GameData.row - 1) then
                        cs_coroutine.start(function()
                            self:Move()
                        end)
                    end
                end
            end
        end
    end
end

---星星移动
function GameControl:Move()
    coroutine.yield(CS.UnityEngine.WaitForSeconds(0.3))
    self:ShiftStarsLeft();
end

---如果一列为空，左移星星
function GameControl:ShiftStarsLeft()
    local Emptys = {}
    for y = 1, GameData.colume do
        if (self:IsColumnEmpty(y)) then
            Emptys[y] = true;
        else
            Emptys[y] = false;
        end
    end

    if (self.check) then
        cs_coroutine.stop(self.check);
    end
    self.check = cs_coroutine.start(function()
        self:MoveColume(Emptys)
    end)
end

---向左移动列
---@param Emptys table 为空的列
function GameControl:MoveColume(Emptys)
    for y = #Emptys, 1, -1 do
        if (Emptys[y]) then
            for j = y + 1, GameData.colume do
                for i = 1, GameData.row do
                    if (self.allStarArray[i][j] ~= nil) then
                        self.allStarArray[i][j - 1] = self.allStarArray[i][j];
                        self.allStarArray[i][j - 1].gameObject.transform:DOMove(self.allStarArray[i][j - 1].transform.position + Vector3.left * 108, 0.1):OnStart(function()
                            self.cover:SetActive(true);
                        end);
                        self.allStarArray[i][j - 1].rowIndex = i;
                        self.allStarArray[i][j - 1].columnIndex = j - 1;
                        self.allStarArray[i][j] = nil;
                    end
                end
            end
            coroutine.yield(CS.UnityEngine.WaitForSeconds(0.1))
        end
    end
    self.cover:SetActive(false);
end

---是否有空的一列
---@param y number 检测y列是否为空
function GameControl:IsColumnEmpty(y)
    for x = 1, GameData.row do
        if (self.allStarArray[x][y] ~= nil) then
            return false;
        end
    end
    return true;
end

---游戏是否结束
function GameControl:IsGameOver()
    --如果星星列表是满的，返回false
    if (isFull) then
        return false;
    end

    for i, item in ipairs(self.allStarArray) do
        if (item ~= null) then
            self:RaycastStarOverGame(item);
        end
    end

    if (#self.overGameList >= 2) then
        self.overGameList = {}
        return false
    else
        self.overGameList = {}
        return true;
    end
end

---射线检测是否游戏结束
function GameControl:RaycastStarOverGame(onclickStar)
    local StarTransform = onclickStar.transform;
    for i, direction in ipairs(self.mDerectionList) do
        local origin = StarTransform.position + direction
        local hit = Physics2D.Raycast(Vector2(origin.x, origin.y), Vector2(direction.x, direction.y), self.checkDistance, LayerMask.GetMask("Star"));
        if (hit.collider ~= null) then
            local hitStar = hit.collider.GetComponent(typeof(Star));
            if (onclickStar.color == hitStar.color and not table.indexof(self.overGameList, hitStar)) then
                self.overGameList.Add(hitStar);
                self:RaycastStarOverGame(hitStar);
            end
        end
    end
end

---游戏关卡结束之后
function GameControl:GameOverAfter()
    local count = 0;
    local awardScore = 0;
    coroutine.yield(CS.UnityEngine.WaitForSeconds(1))
    print("清除游戏元素")
    for i, array in pairs(self.allStarArray) do
        for i, item in pairs(array) do
            count = count + 1
            if (item) then
                GameObject.Destroy(item.gameObject);
            end
        end
    end
    self.allStarArray = {}
    for i = 1, GameData.row do
        table.insert(self.allStarArray, {})
    end

    if (count < 10) then
        awardScore = 2000 - count * 100;
        GameData.remainStarScore = awardScore;
    else
        GameData.remainStarScore = 0;
    end

    local game = UIManager.Instance:GetPanel("GamePanel")
    game.remainStarScore.gameObject:SetActive(true);
    coroutine.yield(CS.UnityEngine.WaitForSeconds(2))
    self:CloseRemainStarScore();
    GameData.CurrentScore = GameData.CurrentScore + awardScore;
    GamePanel:Refresh()
    coroutine.yield(CS.UnityEngine.WaitForSeconds(2))
    self:GameOverShow()
    self.awardScore = 0;
end

--- 隐藏奖励文字
function GameControl:CloseRemainStarScore()
    print("隐藏奖励文字")
    local game = UIManager.Instance:GetPanel("GamePanel");
    game.remainStarScore.gameObject:SetActive(false);
end

--- 游戏结束后显示
function GameControl:GameOverShow()
    if (GameData.CurrentScore > GameData.TargetScore) then
        print("游戏胜利")
        GameData.CurrentLevel = GameData.CurrentLevel + 1;
        GameData.TargetScore = GameData.TargetScore + 2500;
        GameData.CurrentScore = 0;
        --print("分数大于目标分数");
        GamePanel:ShowWin()
        coroutine.yield(CS.UnityEngine.WaitForSeconds(2))
        --EndPanel:Open()
        self:CloseWinText()
    else
        --显示失败界面
        print("游戏失败")
        EndPanel:Open()
    end
end

--- 隐藏通关文字
function GameControl:CloseWinText()
    GamePanel:HideWin()
    self:CreateStar();
end

return GameControl